from sage.all import *
from py_ecc.optimized_bn128 import curve_order as p
import os, random

F = GF(p)
g = F(2)
while g**((p - 1) // 2) == 1:
    g += 1

n = 2**6
omega = g**((p - 1) // n)
assert omega**n == 1 and omega**(n // 2) != 1
H = tuple(omega**i for i in range(n))

P = PolynomialRing(F, 'X')
X = P.gen()

Z_H = X**n - 1
assert all(Z_H(H[i]) == 0 for i in range(n))


def fft(points: "list[int]") -> "list[int]":
    """
    DFT as of Cooley-Tukey algorithm, adapted from https://github.com/scipr-lab/libfqfft.git \\
    (method _basic_serial_radix2_FFT in libfqfft/evaluation_domain/domains/basic_radix2_domain_aux.tcc, line 40-79) 
    """
    global F, n, H
    assert len(points) == n
    points = list(map(F, points))


    def bit_reverse(x: int, n: int) -> int:
        """ Reverse the bits of x, assuming it is represented with n bits """
        y = 0
        for _ in range(n):
            y = (y << 1) | (x & 1)
            x >>= 1
        return y


    for i in range(n):
        j = bit_reverse(i, n.bit_length() - 1)
        if j <= i:
            continue
        points[i], points[j] = points[j], points[i]
    
    m = 1
    for _ in range(n.bit_length() - 1):
        w_m = H[(n // (2 * m)) % n]
        for k in range(0, n, 2 * m):
            w = F(1)
            for j in range(m):
                t = w * points[k + j + m]
                points[k + j + m] = points[k + j] - t
                points[k + j] += t
                w *= w_m
        m *= 2
    return points


def ifft(points: "list[int]") -> "list[int]":
    """ INV-DFT as of Cooley-Tukey algorithm """
    global F, p, n
    points = fft(points)
    n_inv = F(n).inverse()
    return [n_inv * points[0]] + [n_inv * point for point in reversed(points[1:])]


evals = [F.random_element() for _ in range(n)]
poly = P(ifft(evals))
assert evals == [poly(H[i]) for i in range(n)]


def lagrange_polynomial(i: int) -> "list[int]":
    """ Compute the i-th Lagrange polynomial of H """
    global n, H, X, Z_H
    assert 0 <= i < n
    poly = H[i] * Z_H // (n * (X - H[i]))
    return poly


def lagrange_evaluations(x: int) -> "list[int]":
    """ Evaluate the Lagrange polynomials of H at x """
    global F, n, omega, H
    x = F(x)
    
    x_pow_n = x**n
    if x_pow_n == 1:
        assert x in H
        i = H.index(x)
        return list(map(F, [0] * i + [1] + [0] * (n - i - 1)))
    
    evals = []
    l = (x_pow_n - 1) // n
    for i in range(n):
        evals.append(l // (x - H[i]))
        l *= omega
    return evals


for i in range(n):
    poly = lagrange_polynomial(i)
    assert fft(list(poly)) == [0] * i + [1] + [0] * (n - i - 1)

lagrange_polynomials = [lagrange_polynomial(i) for i in range(n)]
x = F.random_element()
evals = lagrange_evaluations(x)
assert [poly(x) == y for poly, y in zip(lagrange_polynomials, evals)]


# ---------------------------------
# Test challenge

_secret = list(os.urandom(n))
_poly = P(ifft(_secret))

k = 6
_bs = [random.getrandbits(128) for _ in range(k)]
_polys = [_poly + b * Z_H for b in _bs]

zetas = [F.random_element() for _ in range(k)]
evals = [poly(zeta) for poly, zeta in zip(_polys, zetas)]

Z_H_evals = [Z_H(zeta) for zeta in zetas]
lagrange_evaluations_by_zeta = [lagrange_evaluations(zeta) for zeta in zetas]

for lagrange_evaluations_i, Z_H_eval, y, b in zip(lagrange_evaluations_by_zeta, Z_H_evals, evals, _bs):
    assert sum(a * s for a, s in zip(lagrange_evaluations_i, _secret)) + Z_H_eval * b == y

PR = PolynomialRing(F, [f"s_{i}" for i in range(n)] + [f"b_{i}" for i in range(k)])
secret, bs = PR.gens()[:n], PR.gens()[n:]
secret_weights, bs_weights = [256] * n, [2**128] * k

polys = []
for lagrange_evaluations_i, Z_H_eval, y, b in zip(lagrange_evaluations_by_zeta, Z_H_evals, evals, bs):
    polys.append((
        (sum(a * s for a, s in zip(lagrange_evaluations_i, secret)) - y) * Z_H_eval.inverse()
    ).change_ring(ZZ))

M, mons = Sequence(polys).coefficients_monomials(sparse=False)

L = Matrix.block(ZZ, [[1, M.T],
                      [0, p]])

weights = [mon(*secret_weights, *bs_weights) for mon in mons] + bs_weights
Q = Matrix.diagonal(QQ, [max(weights) // w for w in weights]) 

L *= Q
L = L.LLL()
L /= Q

i = mons.list().index(1)
for row in L:
    row *= sign(row[i])
    if row[i] == 1 and all(0 <= row[j] < 256 for j in range(n)):
        print(row)


"""
Idea for the final challenge:
- A key is generated for AES and the flag is encrypted with it
- Wire polynomial that has the AES key as points in H
- The polynomial is hidden k times with different hiding polynomials of degree 2 and committed to
- The coefficients of the hiding polynomials are generated by a lcg in F with random parameters
- For each commitment, the commitment is opened on 2 points: zeta and zeta * omega, with zeta uniformly random in F
- The challenge is to recover the AES key from the commitments and the openings 
    - mainly the openings, unless there is a way to recover the hiding polynomials from the commitments that I'm not aware of
"""
